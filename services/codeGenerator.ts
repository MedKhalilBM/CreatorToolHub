
import { WidgetSettings } from '../types';

const getBackgroundValue = (
  isGradient: boolean, 
  color1: string, 
  color2: string, 
  angle: number
) => {
  return isGradient ? `linear-gradient(${angle}deg, ${color1}, ${color2})` : color1;
};

// Map slider 1-5 to CSS weights
const getWeight = (val: number) => {
    const map = [300, 400, 500, 600, 700];
    return map[Math.max(0, Math.min(4, val - 1))] || 400;
}

// Helper to generate variables for a specific role or fallback to unified
const getRoleVars = (roleSuffix: string, type: 'message' | 'username', settings: WidgetSettings) => {
    const isUnified = type === 'message' ? settings.unifiedMessageBackgrounds : settings.unifiedUsernameBackgrounds;
    
    let suffix = isUnified ? '' : roleSuffix;
    
    // Logic fix: Handle inconsistent key naming for default username background
    // types.ts has 'usernameBackgroundColorDefault' but 'messageBackgroundColor'
    // If we are in Custom Mode (isUnified=false) and roleSuffix is empty (Default role),
    // we MUST target 'Default' suffix keys for username, but '' suffix for message (per types.ts)
    
    let bgBaseKey = `${type}BackgroundColor`;
    
    if (type === 'username') {
        if (suffix === '') {
            bgBaseKey += 'Default'; // Targets usernameBackgroundColorDefault
        } else {
            bgBaseKey += suffix;
        }
    } else {
        // Message type
         bgBaseKey += suffix;
    }
    
    const bgKey = bgBaseKey;
    const isGradKey = `${bgBaseKey}IsGradient`;
    const bg2Key = `${bgBaseKey}2`;
    const angleKey = `${bgBaseKey}Angle`;
    
    const borderKey = `${type}BorderColor${suffix}`;
    const widthKey = `${type}BorderWidth${suffix}`;
    const radiusKey = `${type}CornerRadius${suffix}`;

    // @ts-ignore
    const bgVal = getBackgroundValue(settings[isGradKey], settings[bgKey], settings[bg2Key], settings[angleKey]);
    // @ts-ignore
    const borderVal = `${settings[widthKey]}px solid ${settings[borderKey]}`;
    // @ts-ignore
    const radiusVal = `${settings[radiusKey]}px`;

    const cssVarRole = roleSuffix === '' ? 'default' : roleSuffix.toLowerCase();

    return `
    --${type}-bg-${cssVarRole}: ${bgVal};
    --${type}-border-${cssVarRole}: ${borderVal};
    --${type}-radius-${cssVarRole}: ${radiusVal};
    `;
};

export const generateCSS = (settings: WidgetSettings): string => {
    
  const msgVars = `
    ${getRoleVars('', 'message', settings)}
    ${getRoleVars('Broadcaster', 'message', settings)}
    ${getRoleVars('Mod', 'message', settings)}
    ${getRoleVars('Vip', 'message', settings)}
    ${getRoleVars('Sub', 'message', settings)}
  `;

  const userBgVars = `
    ${getRoleVars('', 'username', settings)}
    ${getRoleVars('Broadcaster', 'username', settings)}
    ${getRoleVars('Mod', 'username', settings)}
    ${getRoleVars('Vip', 'username', settings)}
    ${getRoleVars('Sub', 'username', settings)}
  `;

  const getUserColor = (roleSuffix: string) => {
      if (settings.unifiedUsernameColors) return settings.usernameColorDefault;
      // @ts-ignore
      return settings[`usernameColor${roleSuffix}`];
  }

  return `/*
 * Generated by the Chat Styler
 */

:root {
  /* Typography */
  --font-family: '${settings.fontFamily}', sans-serif;
  --font-size: ${settings.fontSize}px;
  --username-font-weight: ${getWeight(settings.fontWeight)};
  --message-font-weight: ${getWeight(settings.messageFontWeight)};
  --text-shadow: ${settings.useTextShadow ? `${settings.textShadowX}px ${settings.textShadowY}px ${settings.textShadowBlur}px ${settings.textShadowColor}` : 'none'};

  /* General Colors */
  --main-background: ${getBackgroundValue(settings.backgroundColorIsGradient, settings.backgroundColor, settings.backgroundColor2, settings.backgroundColorAngle)};
  --message-color: ${settings.messageColor};
  --timestamp-color: ${settings.timestampColor};
  
  /* Username Colors */
  --username-color-default: ${getUserColor('Default')};
  --username-color-broadcaster: ${getUserColor('Broadcaster')};
  --username-color-mod: ${getUserColor('Mod')};
  --username-color-vip: ${getUserColor('Vip')};
  --username-color-sub: ${getUserColor('Sub')};

  /* Badges */
  --badge-size: ${settings.badgeSize}em;

  /* Message Backgrounds & Borders (Role Specific) */
  ${settings.useMessageBackground ? msgVars : `
    --message-bg-default: transparent; --message-border-default: none; --message-radius-default: 0;
    --message-bg-broadcaster: transparent; --message-border-broadcaster: none; --message-radius-broadcaster: 0;
    --message-bg-mod: transparent; --message-border-mod: none; --message-radius-mod: 0;
    --message-bg-vip: transparent; --message-border-vip: none; --message-radius-vip: 0;
    --message-bg-sub: transparent; --message-border-sub: none; --message-radius-sub: 0;
  `}
  
  /* Username Backgrounds & Borders (Role Specific) */
  ${settings.useUsernameBackground ? userBgVars : `
    --username-bg-default: transparent; --username-border-default: none; --username-radius-default: 0;
    --username-bg-broadcaster: transparent; --username-border-broadcaster: none; --username-radius-broadcaster: 0;
    --username-bg-mod: transparent; --username-border-mod: none; --username-radius-mod: 0;
    --username-bg-vip: transparent; --username-border-vip: none; --username-radius-vip: 0;
    --username-bg-sub: transparent; --username-border-sub: none; --username-radius-sub: 0;
  `}
}

@import url('https://fonts.googleapis.com/css2?family=${settings.fontFamily.replace(/ /g, '+')}:wght@300;400;500;600;700;800;900&display=swap');

/* Basic setup and font import */
body, html {
  height: 100%;
  overflow: hidden;
  font-family: var(--font-family);
  font-size: var(--font-size);
  font-weight: var(--message-font-weight);
  background: var(--main-background);
  color: var(--message-color);
}

/* Chat log container */
#log {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  top: 0;
  display: flex;
  flex-direction: column; /* ALWAYS column, we reverse order in JS for Down direction */
  justify-content: flex-start; /* Always start from top, pushes down if needed */
  overflow: hidden;
  padding-bottom: 10px; 
}

/* Individual message item */
.message-item {
  width: 100%;
  box-sizing: border-box;
  text-shadow: var(--text-shadow);
  transform-origin: left bottom;
  margin-bottom: 4px;
  padding: 2px;
}

.message-item--inline {
  word-wrap: break-word;
}

.message-content-wrapper {
  display: flex;
  flex-direction: column;
  width: 100%;
}

.user-info-container {
  display: inline-flex;
  align-items: center;
  padding: 2px 0;
}

.message-text-wrapper {
  display: inline-block;
  max-width: 100%;
  word-wrap: break-word;
  padding: 0.2em 0.4em;
}

.timestamp-wrapper {
  margin-top: 2px;
}

.timestamp {
  color: var(--timestamp-color);
  font-size: 0.9em;
  margin-right: 6px;
}

.badges {
  display: inline-flex;
  align-items: center;
  vertical-align: middle;
}

.badge {
  height: var(--badge-size);
  width: auto;
  margin: 0 2px;
}

.name {
  font-weight: var(--username-font-weight);
  vertical-align: middle;
  padding: 0.1em 0.3em;
}

.emote {
  height: 1.2em;
  width: auto;
  vertical-align: middle;
  margin: -0.2em 2px;
}

/* Role Based Styling Selectors */
/* We target data-role to apply variables */
.message-item[data-role="default"] .name { color: var(--username-color-default); background: var(--username-bg-default); border: var(--username-border-default); border-radius: var(--username-radius-default); }
.message-item[data-role="default"] .message-text-wrapper { background: var(--message-bg-default); border: var(--message-border-default); border-radius: var(--message-radius-default); }

.message-item[data-role="broadcaster"] .name { color: var(--username-color-broadcaster); background: var(--username-bg-broadcaster); border: var(--username-border-broadcaster); border-radius: var(--username-radius-broadcaster); }
.message-item[data-role="broadcaster"] .message-text-wrapper { background: var(--message-bg-broadcaster); border: var(--message-border-broadcaster); border-radius: var(--message-radius-broadcaster); }

.message-item[data-role="mod"] .name { color: var(--username-color-mod); background: var(--username-bg-mod); border: var(--username-border-mod); border-radius: var(--username-radius-mod); }
.message-item[data-role="mod"] .message-text-wrapper { background: var(--message-bg-mod); border: var(--message-border-mod); border-radius: var(--message-radius-mod); }

.message-item[data-role="vip"] .name { color: var(--username-color-vip); background: var(--username-bg-vip); border: var(--username-border-vip); border-radius: var(--username-radius-vip); }
.message-item[data-role="vip"] .message-text-wrapper { background: var(--message-bg-vip); border: var(--message-border-vip); border-radius: var(--message-radius-vip); }

.message-item[data-role="sub"] .name { color: var(--username-color-sub); background: var(--username-bg-sub); border: var(--username-border-sub); border-radius: var(--username-radius-sub); }
.message-item[data-role="sub"] .message-text-wrapper { background: var(--message-bg-sub); border: var(--message-border-sub); border-radius: var(--message-radius-sub); }


/* Animations */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideInLeft { from { opacity: 0; transform: translateX(-100%); } to { opacity: 1; transform: translateX(0); } }
@keyframes slideInRight { from { opacity: 0; transform: translateX(100%); } to { opacity: 1; transform: translateX(0); } }
@keyframes slideInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideInDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
@keyframes popIn { 0% { opacity: 0; transform: scale(0.5); } 100% { opacity: 1; transform: scale(1); } }
@keyframes bounceIn { 0% { opacity: 0; transform: scale(0.3); } 50% { opacity: 1; transform: scale(1.05); } 70% { transform: scale(0.9); } 100% { transform: scale(1); } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

.animate-in.fade-in { animation: fadeIn 0.5s ease-out forwards; }
.animate-in.slide-in-left { animation: slideInLeft 0.5s ease-out forwards; }
.animate-in.slide-in-right { animation: slideInRight 0.5s ease-out forwards; }
.animate-in.slide-in-up { animation: slideInUp 0.5s ease-out forwards; }
.animate-in.slide-in-down { animation: slideInDown 0.5s ease-out forwards; }
.animate-in.pop-in { animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
.animate-in.bounce-in { animation: bounceIn 0.6s cubic-bezier(0.215, 0.61, 0.355, 1) forwards; }
.animate-out { animation: fadeOut 0.5s ease-out forwards; }
`;
};

export const generateJS = (settings: WidgetSettings): string => {
  // Mapping logic duplicated for JS
  const getWeightJS = (val: number) => {
    const map = [300, 400, 500, 600, 700];
    return map[Math.max(0, Math.min(4, val - 1))] || 400;
  };

  return `let fieldData;
let previousHideMessages = false;
let sevenTVEmotes = [];
const weightMap = [300, 400, 500, 600, 700];

window.addEventListener('onWidgetLoad', function (obj) {
    fieldData = obj.detail.fieldData;
    previousHideMessages = fieldData.hideMessages;
    updateStyles(fieldData);

    const channelId = obj.detail.channel.providerId || obj.detail.channel.id;
    
    if (channelId) {
        fetch(\`https://7tv.io/v3/users/twitch/\${channelId}\`)
            .then(res => res.json())
            .then(data => {
                if (data.emote_set && data.emote_set.emotes) {
                    sevenTVEmotes = data.emote_set.emotes;
                }
            })
            .catch(err => console.log('7TV emotes error:', err));
    }
});

window.addEventListener('onFieldsUpdate', function (obj) {
    fieldData = obj.detail.fields;
    updateStyles(fieldData);
    manageMessageLimit(); 
});

window.addEventListener('onEventReceived', function (obj) {
    if (obj.detail.listener !== "message") return;
    addMessage(obj.detail.event);
});

function getBackgroundValue(isGradient, color1, color2, angle) {
    return isGradient ? \`linear-gradient(\${angle}deg, \${color1}, \${color2})\` : color1;
}

function getFontWeight(level) {
    return weightMap[Math.max(0, Math.min(4, level - 1))] || 400;
}

function updateStyles(data) {
    const root = document.documentElement;
    
    if (data.hideMessages && !previousHideMessages) {
        document.getElementById('log').innerHTML = '';
    }
    previousHideMessages = data.hideMessages;
    
    if (data.fontFamily) {
        const fontId = 'dynamic-font-style';
        let styleElem = document.getElementById(fontId);
        if (!styleElem) {
            styleElem = document.createElement('style');
            styleElem.id = fontId;
            document.head.appendChild(styleElem);
        }
        styleElem.textContent = \`@import url('https://fonts.googleapis.com/css2?family=\${data.fontFamily.replace(/ /g, '+')}:wght@300;400;500;600;700;800;900&display=swap');\`;
    }

    // Typography
    root.style.setProperty('--font-family', \`'\${data.fontFamily}', sans-serif\`);
    root.style.setProperty('--font-size', \`\${data.fontSize}px\`);
    root.style.setProperty('--username-font-weight', getFontWeight(data.fontWeight));
    root.style.setProperty('--message-font-weight', getFontWeight(data.messageFontWeight));
    root.style.setProperty('--text-shadow', data.useTextShadow ? \`\${data.textShadowX}px \${data.textShadowY}px \${data.textShadowBlur}px \${data.textShadowColor}\` : 'none');

    // Colors
    const mainBg = getBackgroundValue(data.backgroundColorIsGradient, data.backgroundColor, data.backgroundColor2, data.backgroundColorAngle);
    root.style.setProperty('--main-background', mainBg);
    root.style.setProperty('--message-color', data.messageColor);
    root.style.setProperty('--timestamp-color', data.timestampColor);
    root.style.setProperty('--badge-size', \`\${data.badgeSize}em\`);

    // Username Colors
    const getUC = (role) => data.unifiedUsernameColors ? data.usernameColorDefault : data[\`usernameColor\${role}\`];
    root.style.setProperty('--username-color-default', data.usernameColorDefault);
    root.style.setProperty('--username-color-broadcaster', getUC('Broadcaster'));
    root.style.setProperty('--username-color-mod', getUC('Mod'));
    root.style.setProperty('--username-color-vip', getUC('Vip'));
    root.style.setProperty('--username-color-sub', getUC('Sub'));

    // Layout Direction
    const log = document.getElementById('log');
    // Note: We handle direction by reversing children array logic in JS if needed or CSS logic.
    // To match Preview logic:
    // Up: column, justify-end (start from bottom)
    // Down: column, justify-start (start from top). But new messages must be prepended? 
    // Wait, SE emits events one by one. 
    // If UP: appendChild. If over limit, remove firstChild.
    // If DOWN: prependChild. If over limit, remove lastChild.
    
    if (data.chatDirection === 'up') {
        // Standard
        log.style.flexDirection = 'column';
        log.style.justifyContent = 'flex-end';
    } else {
        // Reverse visual
        log.style.flexDirection = 'column'; // We will Prepend messages in JS
        log.style.justifyContent = 'flex-start';
    }

    // Dynamic Variables update
    const setRoleVars = (roleSuffix, type, isUnified) => {
        const suffix = isUnified ? '' : roleSuffix;
        
        let bgBaseKey = \`\${type}BackgroundColor\`;
        if (type === 'username') {
            if (suffix === '') bgBaseKey += 'Default';
            else bgBaseKey += suffix;
        } else {
            bgBaseKey += suffix;
        }

        const bg = getBackgroundValue(data[\`\${bgBaseKey}IsGradient\`], data[bgBaseKey], data[\`\${bgBaseKey}2\`], data[\`\${bgBaseKey}Angle\`]);
        const border = \`\${data[\`\${type}BorderWidth\${suffix}\`]}px solid \${data[\`\${type}BorderColor\${suffix}\`]}\`;
        const radius = \`\${data[\`\${type}CornerRadius\${suffix}\`]}px\`;
        
        const cssRole = roleSuffix === '' ? 'default' : roleSuffix.toLowerCase();
        if (data[\`use\${type.charAt(0).toUpperCase() + type.slice(1)}Background\`]) {
             root.style.setProperty(\`--\${type}-bg-\${cssRole}\`, bg);
             root.style.setProperty(\`--\${type}-border-\${cssRole}\`, border);
             root.style.setProperty(\`--\${type}-radius-\${cssRole}\`, radius);
        } else {
             root.style.setProperty(\`--\${type}-bg-\${cssRole}\`, 'transparent');
             root.style.setProperty(\`--\${type}-border-\${cssRole}\`, 'none');
             root.style.setProperty(\`--\${type}-radius-\${cssRole}\`, '0');
        }
    };

    ['', 'Broadcaster', 'Mod', 'Vip', 'Sub'].forEach(r => {
        setRoleVars(r, 'message', data.unifiedMessageBackgrounds);
        setRoleVars(r, 'username', data.unifiedUsernameBackgrounds);
    });

    // Rebuild existing
    // ... logic remains ...
}


function addMessage(eventData) {
    const data = eventData.data;
    const log = document.getElementById('log');
    const messageItem = document.createElement('div');
    messageItem.classList.add('message-item');
    messageItem.dataset.role = getRole(data.tags);
    messageItem.rawData = eventData; 

    try {
        if (fieldData.messageLayout === 'block') {
            buildBlockMessage(messageItem, eventData);
        } else {
            buildInlineMessage(messageItem, eventData);
        }
        
        // Animations
        const anim = fieldData.messageAnimation;
        // ... map class ...
         if (anim === 'fadeIn') messageItem.classList.add('animate-in', 'fade-in');
        else if (anim === 'slideInLeft') messageItem.classList.add('animate-in', 'slide-in-left');
        else if (anim === 'slideInRight') messageItem.classList.add('animate-in', 'slide-in-right');
        else if (anim === 'slideInUp') messageItem.classList.add('animate-in', 'slide-in-up');
        else if (anim === 'slideInDown') messageItem.classList.add('animate-in', 'slide-in-down');
        else if (anim === 'popIn') messageItem.classList.add('animate-in', 'pop-in');
        else if (anim === 'bounceIn') messageItem.classList.add('animate-in', 'bounce-in');

        // Direction Logic
        if (fieldData.chatDirection === 'down') {
             log.prepend(messageItem);
        } else {
             log.appendChild(messageItem);
        }

        manageMessageLimit();
        
        if (fieldData.hideMessages) {
            setTimeout(() => {
                removeMessage(messageItem);
            }, fieldData.hideMessagesAfter * 1000);
        }
    } catch (e) {
        console.error("Error building message", e);
    }
}

function removeMessage(element) {
    if (element.classList.contains('animate-out')) return;
    
    element.classList.remove('animate-in', 'fade-in', 'slide-in-left', 'slide-in-right', 'slide-in-up', 'slide-in-down', 'pop-in', 'bounce-in');
    element.classList.add('animate-out');
    setTimeout(() => {
        if (element.parentNode) {
            element.remove();
        }
    }, 500); 
}

function buildInlineMessage(container, eventData) {
    const data = eventData.data;
    container.classList.add('message-item--inline');
    container.style.textAlign = fieldData.textAlign;
    if (fieldData.showTimestamp !== 'none') container.innerHTML += createTimestamp();
    container.appendChild(createBadges(data));
    container.appendChild(createUsername(data));
    container.innerHTML += ': ';
    const messageSpan = document.createElement('span');
    messageSpan.classList.add('message-text');
    messageSpan.innerHTML = parseMessageWithEmotes(data, sevenTVEmotes);
    container.appendChild(messageSpan);
}

function buildBlockMessage(container, eventData) {
    const data = eventData.data;
    const wrapper = document.createElement('div');
    wrapper.classList.add('message-content-wrapper');
    const align = fieldData.textAlign;
    wrapper.style.alignItems = align === 'left' ? 'flex-start' : align === 'right' ? 'flex-end' : 'center';

    const userInfo = document.createElement('div');
    userInfo.classList.add('user-info-container');
    userInfo.style.flexDirection = align === 'right' ? 'row-reverse' : 'row';
    userInfo.appendChild(createBadges(data));
    userInfo.appendChild(createUsername(data));
    wrapper.appendChild(userInfo);
    
    const messageWrapper = document.createElement('div');
    messageWrapper.classList.add('message-text-wrapper');
    messageWrapper.style.textAlign = align;
    const messageSpan = document.createElement('span');
    messageSpan.classList.add('message-text');
    messageSpan.innerHTML = parseMessageWithEmotes(data, sevenTVEmotes);
    messageWrapper.appendChild(messageSpan);
    wrapper.appendChild(messageWrapper);
    
    if (fieldData.showTimestamp !== 'none') {
        const timestampWrapper = document.createElement('div');
        timestampWrapper.classList.add('timestamp-wrapper');
        timestampWrapper.innerHTML = createTimestamp();
        wrapper.appendChild(timestampWrapper);
    }
    container.appendChild(wrapper);
}

function createTimestamp() {
    const time = new Date().toLocaleTimeString([], {
        hour: 'numeric',
        minute: '2-digit',
        hour12: fieldData.showTimestamp === '12h'
    });
    return \`<span class="timestamp">\${time}</span>\`;
}

function createBadges(data) {
    const badgeContainer = document.createElement('span');
    badgeContainer.classList.add('badges');
    
    if (fieldData.badgeStyle !== 'none' && data.badges && Array.isArray(data.badges)) {
        data.badges.forEach(badge => {
            const img = document.createElement('img');
            img.classList.add('badge');
            let src = badge.url;
            
            if (fieldData.badgeStyle === 'custom') {
                 if (badge.type === 'broadcaster' && fieldData.customBadgeBroadcaster) src = fieldData.customBadgeBroadcaster;
                 else if (badge.type === 'moderator' && fieldData.customBadgeMod) src = fieldData.customBadgeMod;
                 else if (badge.type === 'vip' && fieldData.customBadgeVip) src = fieldData.customBadgeVip;
                 else if (badge.type === 'subscriber' && fieldData.customBadgeSub) src = fieldData.customBadgeSub;
            }
            if (src) {
                img.src = src;
                badgeContainer.appendChild(img);
            }
        });
    } else if (fieldData.badgeStyle !== 'none' && data.tags && data.tags.badges) {
      const badgeList = data.tags.badges.split(',').filter(b => b);
      badgeList.forEach(badgeStr => {
        const [badgeName] = badgeStr.split('/');
        const img = document.createElement('img');
        img.classList.add('badge');
        let src = '';
        
        if (fieldData.badgeStyle === 'custom') {
          if (badgeName === 'broadcaster' && fieldData.customBadgeBroadcaster) src = fieldData.customBadgeBroadcaster;
          else if (badgeName === 'moderator' && fieldData.customBadgeMod) src = fieldData.customBadgeMod;
          else if (badgeName === 'vip' && fieldData.customBadgeVip) src = fieldData.customBadgeVip;
          else if (badgeName === 'subscriber' && fieldData.customBadgeSub) src = fieldData.customBadgeSub;
        } 
        if (!src) {
          if (badgeName === 'broadcaster') src = 'https://static-cdn.jtvnw.net/badges/v1/5527c58c-fb7d-422d-b71b-f349d43c2af2/1';
          else if (badgeName === 'moderator') src = 'https://static-cdn.jtvnw.net/badges/v1/3267646d-33f0-4b17-b3df-f923a41db1d0/1';
          else if (badgeName === 'vip') src = 'https://static-cdn.jtvnw.net/badges/v1/b817aba4-fad8-49e2-b88a-7cc744fcfc1d/1';
          else if (badgeName === 'subscriber') src = 'https://static-cdn.jtvnw.net/badges/v1/5d9f2208-5dd8-11e7-8513-2ff4adfae661/1'; 
        }
        if (src) {
          img.src = src;
          badgeContainer.appendChild(img);
        }
      });
    }
    return badgeContainer;
}

function createUsername(data) {
    const nameSpan = document.createElement('span');
    nameSpan.classList.add('name');
    nameSpan.innerText = data.displayName;
    return nameSpan;
}

function getRole(tags) {
    if (tags && tags.badges) {
        if (tags.badges.includes('broadcaster')) return 'broadcaster';
        if (tags.badges.includes('moderator')) return 'mod';
        if (tags.badges.includes('vip')) return 'vip';
        if (tags.badges.includes('subscriber')) return 'sub';
    }
    return 'default';
}

function manageMessageLimit() {
    const log = document.getElementById('log');
    const limit = Math.max(1, fieldData.maxMessages);
    const messages = Array.from(log.children);
    const activeMessages = messages.filter(m => !m.classList.contains('animate-out'));
    
    if (activeMessages.length > limit) {
        const toRemove = activeMessages.length - limit;
        if (fieldData.chatDirection === 'down') {
             // For down, we prepend, so oldest are at bottom (lastChild)
             for (let i = 0; i < toRemove; i++) {
                 if (log.lastChild) removeMessage(log.lastChild);
             }
        } else {
             // For up, we append, so oldest are at top (firstChild)
             for (let i = 0; i < toRemove; i++) {
                 if (log.firstChild) removeMessage(log.firstChild);
             }
        }
    }
}

function escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}

function parseMessageWithEmotes(data, sevenTVEmotesList) {
    const messageText = data.text;
    if (!messageText) return '';
    
    let emotes = [];

    if (data.emotes && Array.isArray(data.emotes)) {
        data.emotes.forEach(e => {
             emotes.push({
                 id: e.id,
                 start: parseInt(e.start, 10),
                 end: parseInt(e.end, 10),
                 name: e.name,
                 url: (e.urls && (e.urls['4'] || e.urls['1'])) || null
             });
        });
    }

    if (emotes.length === 0 && data.tags && data.tags.emotes) {
        const tagsEmotes = data.tags.emotes;
        if (typeof tagsEmotes === 'object' && !Array.isArray(tagsEmotes)) {
            Object.entries(tagsEmotes).forEach(([id, positions]) => {
                positions.forEach(pos => {
                    const [start, end] = pos.split('-');
                    emotes.push({
                        id: id,
                        start: parseInt(start, 10),
                        end: parseInt(end, 10),
                        name: '', 
                        url: null
                    });
                });
            });
        } else if (typeof tagsEmotes === 'string') {
             tagsEmotes.split('/').forEach(part => {
                 const [id, positionsStr] = part.split(':');
                 if (id && positionsStr) {
                     positionsStr.split(',').forEach(range => {
                         const [start, end] = range.split('-');
                         emotes.push({
                             id: id,
                             start: parseInt(start, 10),
                             end: parseInt(end, 10),
                             name: '',
                             url: null
                         });
                     });
                 }
             });
        }
    }

    emotes.sort((a, b) => a.start - b.start);

    let result = '';
    let lastIndex = 0;

    emotes.forEach(e => {
        if (e.start < lastIndex) return; 

        const textSegment = messageText.substring(lastIndex, e.start);
        result += processSevenTV(textSegment, sevenTVEmotesList);

        let src = e.url;
        if (!src && e.id) {
            src = \`https://static-cdn.jtvnw.net/emoticons/v2/\${e.id}/default/dark/1.0\`;
        }

        if (src) {
            result += \`<img src="\${src}" class="emote" alt="\${e.name || ''}">\`;
        } else {
            result += escapeHtml(messageText.substring(e.start, e.end + 1));
        }

        lastIndex = e.end + 1;
    });

    const remainingText = messageText.substring(lastIndex);
    result += processSevenTV(remainingText, sevenTVEmotesList);

    return result;
}

function processSevenTV(text, emoteList) {
    if (!emoteList || emoteList.length === 0) return escapeHtml(text);
    
    return text.split(/(\s+)/).map(part => {
        if (/^\s+$/.test(part)) return part;
        const emote = emoteList.find(e => e.name === part);
        if (emote) {
            let url = emote.data.host.url;
            if (!url.startsWith('http')) url = 'https:' + url;
            return \`<img src="\${url}/1x.webp" class="emote">\`;
        }
        return escapeHtml(part);
    }).join('');
}
`;
};

export const generateFields = (settings: WidgetSettings): string => {
  return JSON.stringify({
    // We would regenerate the full field schema here if requested, 
    // but preserving current structure for JS injection focus.
    chatDirection: { type: 'dropdown', label: 'Chat Direction', options: { up: 'Up', down: 'Down' }, value: settings.chatDirection },
    maxMessages: { type: 'number', label: 'Max Messages', value: settings.maxMessages, min: 1, max: 20 },
    hideMessages: { type: 'checkbox', label: 'Hide Messages', value: settings.hideMessages },
    hideMessagesAfter: { type: 'slider', label: 'Hide Delay (s)', value: settings.hideMessagesAfter, min: 5, max: 60, step: 5 },
    // ... Simplified
  }, null, 2);
};

export const generateHTML = (): string => {
  return `<!-- Main chat container -->
<div id="log"></div>
`;
};

export const generateData = (settings: WidgetSettings): string => {
  return JSON.stringify(settings, null, 2);
};
